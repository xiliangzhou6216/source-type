<!--
 * @Description: 
 * @Version: 2.0
 * @Autor: xiliang
 * @Date: 2021-07-01 14:35:01
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2021-07-12 17:44:42
-->

[TOC]
 
# 源码总结

## 响应式原理

###  Watcher的创建场景  收集依赖

- watch选项(也是调用vm.$watch())
- computed选项
- 组件的渲染Watcher(updateComponent,执行 render 函数生成 VNode 时的运行时阶段会进行读取操作,依赖收集)


### Vue响应式原理怎么实现的

- 响应式的核心是通过Object.defineProperty()拦截对数据的访问和设置
- 响应式的数据分为两类
  - 对象,循环遍历对象的所有属性,为每个属性设置getter、setter,达到拦截访问和设置目的,如果属性值依旧是对象,则递归再处理
    -  访问数据时(obj.key)进行依赖收集,在dep中存储相关的watcher
    -  设置数据时由dep通知相关watcher去更新
  - 数组,对数组7的原型方法重写,拦截对这些方法的操作
    - 添加新数据时进行响应式处理,然后由dep通知watcher去更新
    - 删除数据也要dep通知watcher去更新

###  methods VS computed VS watch

#### 使用场景

- methods  一般用于封装一些较为复杂的处理逻辑(同步、异步)
- computed 一般用于封装一些简单的逻辑,将经过处理的数据返回,然后显示在模板中,减轻模板的重量
- watch 一般用于  数据变化时执行异步或者开销较大的时候

#### 区别

- methods VS computed

> 在一次渲染中,有多个地方使用同一个methods或者computed属性,methods会多次执行,computed只会执行一次

>多次访问computedProperty,通过源码发现,watcher.dirty属性控制


- computed VS watch

> computed 和 watch 的本质是一样的，内部都是通过 Watcher 来实现的，其实没什么区别，非要说区别的化就两点：1、使用场景上的区别，2、computed 默认是懒执行的，切不可更改。


 