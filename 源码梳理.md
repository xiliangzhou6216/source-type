<!--
 * @Description: 
 * @Version: 2.0
 * @Autor: xiliang
 * @Date: 2021-07-01 14:35:01
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2021-08-02 15:49:55
-->

[TOC]
 
# 源码总结

## 响应式原理

###  Watcher的创建场景  收集依赖

- watch选项(也是调用vm.$watch())

- computed选项

- 组件的渲染Watcher(updateComponent,执行 render 函数生成 VNode 时的运行时阶段会进行读取操作,依赖收集)


### Vue响应式原理怎么实现的

- 响应式的核心是通过Object.defineProperty()拦截对数据的访问和设置

- 响应式的数据分为两类

  - 对象,循环遍历对象的所有属性,为每个属性设置getter、setter,达到拦截访问和设置目的,如果属性值依旧是对象,则递归再处理

    -  访问数据时(obj.key)进行依赖收集,在dep中存储相关的watcher

    -  设置数据时由dep通知相关watcher去更新
    
  - 数组,对数组7的原型方法重写,拦截对这些方法的操作

    - 添加新数据时进行响应式处理,然后由dep通知watcher去更新

    - 删除数据也要dep通知watcher去更新

###  methods VS computed VS watch

#### 使用场景

- methods  一般用于封装一些较为复杂的处理逻辑(同步、异步)

- computed 一般用于封装一些简单的逻辑,将经过处理的数据返回,然后显示在模板中,减轻模板的重量

- watch 一般用于  数据变化时执行异步或者开销较大的时候

#### 区别

- methods VS computed

> 在一次渲染中,有多个地方使用同一个methods或者computed属性,methods会多次执行,computed只会
执行一次

>多次访问computedProperty,通过源码发现,watcher.dirty属性控制


- computed VS watch

> computed 和 watch 的本质是一样的，内部都是通过 Watcher 来实现的，其实没什么区别，非要说区别的化就两点：1、使用场景上的区别，2、computed 默认是懒执行的，切不可更改。

- computed 会标记 Watcher.lazy属性为true

- watch 会标记 Watcher.user属性为true


### Watcher要收集Dep的依赖

- 方便Watcher去管理Dep,当使用watch选项的依赖收集,以及调用unwatch时移除相关依赖 取消监听 

- 如果 Watcher 不收集 dep,没办法手动移除改Watcher相关的依赖,除非组件实例被销毁


## 异步更新

### 1. Vue 的异步更新机制是如何实现的

异步更新机制的核心利用浏览器的异步任务队列完成的，首选微任务队列，宏任务队列次之。

当响应式数据更新后，会调用dep.notify方法，通知dep中收集的watcher去执行update方法，watcher.update()会将watcher自己放入一个watcher队列(全局的queue数据组)

然后通过nextTick方法将一个刷新watcher队列的方法(flushSchedulerQueue函数)放入callbacks数组中，异步队列中没有flushCallbacks函数，则执行timerFunc(timerFunc = () => { p.then(flushCallbacks)}) 函数，将 flushCallbacks 函数放入异步任务队列。
    

flushCallbacks()方法负责执行callbacks数组的所有的 flushSchedulerQueue函数，
flushSchedulerQueue()方法负责刷新watcher队列，从而执行queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段。



### 2. Vue 的 nextTick API 是如何实现的

- 将传递的回调函数通过try catch包裹然后放入callbacks数组

- 执行timeFunc函数，在浏览器的异步任务放入一个刷新callback数组的函数
 

## 全局API

### 1. 组件的name有什么用

- keep-alive时 可以用name做include或者exclude的值  源码中render 需要获取组件name

- 递归组件 调用自己时  自己放到自己components中

- vue-tools 调试时 name提供组件语义信息

### 2. 检测变化的注意事项

1. 对象

- Vue.set(vm.someObject, 'b', 2)   // 给已有对象添加新的属性

- this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })  // 给对象添加多个新属性

2. 数组

- Vue.set(vm.items, indexOfItem, newValue) 或者 vm.items.splice(indexOfItem, 1, newValue)  // 当你利用索引直接设置一个数组项时

- vm.items.splice(newLength)  // 当你修改数组的长度时

### 3. Vue.use(plugin) 做了什么？

负责安装plugin插件，其实就是执行插件提供的install方法

- 首先判断插件是否安装过

- 如果没有，则执行插件提供的install方法安装插件，具体做什么由插件自己决定

### 4. Vue.component(compName, Comp) 做了什么？

负责注册全局组件。将组件配置注册到全局配置的components选项上（options.components）,然后各个子组件在生成vnode时会将全局的components选项合并到局部的components配置项上

directive,filter同上

### 5. Vue.mixin(options) 做了什么？

负责在Vue的全局配置上合并options配置,然后在每个组件生成 vnode 时会将全局配置合并到组件自身的配置上来

### 6. Vue.extend(options) 做了什么？

Vue.extend 基于 Vue 创建一个子类,达到继承的目的


### 7. Vue.nextTick(cb) 做了什么？

延迟回调函数cb的执行，一般用于this.key = newVal 更改数据后，像立即获取更改过后的DOM数据

```js
this.key = 'new val'

Vue.nextTick(function() {
  // DOM 更新了
})
```
-  **this.key = new val ，** 触发依赖通知更新，将负责更新的watcher放入watcher队列

-将刷新watcher队列的函数放到callbacks数组的函数

- 在浏览器的异步任务队列中放入一个刷新callbacks数组的函数

- **Vue.nextTick(cb)**来插队，将cb函数放入callbacks数组

- 待将来的某个时刻执行刷新 callbacks 数组的函数

- 然后执行 callbacks 数组中的众多函数，触发 watcher.run 的执行，更新 DOM

- 由于 cb 函数是在后面放到 callbacks 数组，所以这就保证了先完成的 DOM 更新，再执行 cb 函数

