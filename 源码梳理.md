<!--
 * @Description: 
 * @Version: 2.0
 * @Autor: xiliang
 * @Date: 2021-07-01 14:35:01
 * @LastEditors: Please set LastEditors
 * @LastEditTime: 2021-07-23 16:59:27
-->

[TOC]
 
# 源码总结

## 响应式原理

###  Watcher的创建场景  收集依赖

- watch选项(也是调用vm.$watch())

- computed选项

- 组件的渲染Watcher(updateComponent,执行 render 函数生成 VNode 时的运行时阶段会进行读取操作,依赖收集)


### Vue响应式原理怎么实现的

- 响应式的核心是通过Object.defineProperty()拦截对数据的访问和设置

- 响应式的数据分为两类

  - 对象,循环遍历对象的所有属性,为每个属性设置getter、setter,达到拦截访问和设置目的,如果属性值依旧是对象,则递归再处理

    -  访问数据时(obj.key)进行依赖收集,在dep中存储相关的watcher

    -  设置数据时由dep通知相关watcher去更新
    
  - 数组,对数组7的原型方法重写,拦截对这些方法的操作

    - 添加新数据时进行响应式处理,然后由dep通知watcher去更新

    - 删除数据也要dep通知watcher去更新

###  methods VS computed VS watch

#### 使用场景

- methods  一般用于封装一些较为复杂的处理逻辑(同步、异步)

- computed 一般用于封装一些简单的逻辑,将经过处理的数据返回,然后显示在模板中,减轻模板的重量

- watch 一般用于  数据变化时执行异步或者开销较大的时候

#### 区别

- methods VS computed

> 在一次渲染中,有多个地方使用同一个methods或者computed属性,methods会多次执行,computed只会
执行一次

>多次访问computedProperty,通过源码发现,watcher.dirty属性控制


- computed VS watch

> computed 和 watch 的本质是一样的，内部都是通过 Watcher 来实现的，其实没什么区别，非要说区别的化就两点：1、使用场景上的区别，2、computed 默认是懒执行的，切不可更改。

- computed 会标记 Watcher.lazy属性为true

- watch 会标记 Watcher.user属性为true


### Watcher要收集Dep的依赖

- 方便Watcher去管理Dep,当使用watch选项的依赖收集,以及调用unwatch时移除相关依赖 取消监听 

- 如果 Watcher 不收集 dep,没办法手动移除改Watcher相关的依赖,除非组件实例被销毁


## 异步更新

### 1. Vue 的异步更新机制是如何实现的

异步更新机制的核心利用浏览器的异步任务队列完成的，首选微任务队列，宏任务队列次之。

当响应式数据更新后，会调用dep.notify方法，通知dep中收集的watcher去执行update方法，watcher.update()会将watcher自己放入一个watcher队列(全局的queue数据组)

然后通过nextTick方法将一个刷新watcher队列的方法(flushSchedulerQueue函数)放入callbacks数组中，异步队列中没有flushCallbacks函数，则执行timerFunc(timerFunc = () => { p.then(flushCallbacks)}) 函数，将 flushCallbacks 函数放入异步任务队列。
    

flushCallbacks()方法负责执行callbacks数组的所有的 flushSchedulerQueue函数，
flushSchedulerQueue()方法负责刷新watcher队列，从而执行queue 数组中每一个 watcher 的 run 方法，从而进入更新阶段。



### 2. Vue 的 nextTick API 是如何实现的

- 将传递的回调函数通过try catch包裹然后放入callbacks数组

- 执行timeFunc函数，在浏览器的异步任务放入一个刷新callback数组的函数
 

## 全局API

### 1. 组件的name有什么用

- keep-alive时 可以用name做include或者exclude的值  源码中render 需要获取组件name

- 递归组件 调用自己时

- vue-tools 调试时 name提供组件语义信息

